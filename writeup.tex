% Security of mixnets with a cascade topology.

\documentclass[letter]{article}
\usepackage{color,soul}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[margin=4cm]{geometry}
\usepackage{graphics}
\usepackage[toc,page]{appendix}
\usepackage[font={small}]{caption}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{parskip}
\usepackage{framed}
\usepackage{multicol}

\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\def\dashuline{\bgroup
  \ifdim\ULdepth=\maxdimen  % Set depth based on font, if not set already
	  \settodepth\ULdepth{(j}\advance\ULdepth.4pt\fi
  \markoverwith{\kern.15em
	\vtop{\kern\ULdepth \hrule width .3em}%
	\kern.15em}\ULon}

\newcounter{foot}
\setcounter{foot}{1}
\setlength\parindent{2em}


%%%%% Macros. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\DeclareMathAlphabet\mathbfcal{OMS}{cmsy}{b}{n}
\newcommand{\note}[1]{}

% Sets
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\Zmodp}{\mathbb{Z}_p}
\newcommand{\Zmodq}{\mathbb{Z}_q}
\newcommand{\N}{\mathbb{N}}
\newcommand{\bits}{\{0,1\}}
\newcommand*\Union{\bigcup}
\newcommand*\Intersect{\bigcap}
\newcommand*\union{\cup}
\newcommand*\intersect{\cap}
\newcommand*\by{\times}
%\newcommand{\getsr}{\xleftarrow{\text{\tiny{\$}}}}
\newcommand{\getsr}{\mathrel{\leftarrow\mkern-14mu\leftarrow}}

% Asymptotics
\newcommand{\negl}{\proc{negl}}
\newcommand{\poly}{\proc{poly}}

\newcommand{\heading}[1]{\noindent \textsc{#1}}

% Misc.
\newcommand{\brackets}[1]{\langle #1 \rangle}
\newcommand{\view}{\mathsf{view}}
\newcommand{\class}[1]{\mathbf{#1}}

\newcommand{\pk}{K}
\newcommand{\sk}{k}
\newcommand{\varm}{M}
\newcommand{\varc}{C}
\newcommand{\varr}{R}

\newcommand{\advD}{D}

\newcommand{\gen}{\mathcal{G}}
\newcommand{\enc}{\mathcal{E}}
\newcommand{\dec}{\mathcal{D}}

%%%%% Title. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\date{\today}
\title{Verifying a shuffle in zero-knowledge}
  \author{Chris Patton}

\setcounter{tocdepth}{2}

\renewcommand{\cal}[1]{\mathcal{#1}}

%%%%% Content. %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

  \maketitle

\section{Introduction}

A mixnet (sometimes called a ``mix-network'') is a service designed to
facilitate anonymous communications over the internet \cite{chaum81}. Each of a
set of users $\cal{Q} = \{P_1, \dots, P_n\}$ wish to send a message to a user in
$\cal{Q}$. Each encrypts their message $M$ and the identity of the intended
recipient $P_i$ under the public key of the mixnet server (heereafter referred
to as the ``mix'') and transmits the ciphertext.  The mix server waits until it
receives $m \le n$ ciphertexts from $m$ distinct users.  It then decrypts each
message and destination pair under its secret key and transmits each message to
its intended destination. Crucially, the mix transmits the messages in a random
order so as to hide the correspondence between senders and recipients.  As long
as the mix is trusted and the user's ciphertexts are faithfully transmitted to
the mix, this simple approach suffices to preserve anonymity of its
participants.

Normally we think of the mixnet being composed of a cascade of mix servers, each
decrypting, shuffling, then transmitting to the next mix in the cascade until
finally the last server outputs the users' messages. This is meant to distribute
trust so that as long as the messages pass through at least one honest mix,
anonymity is achieved. Still, the trust model here is rather strong. For
example, the mix could send a fake message on behalf of one of the senders, or
redirect it to a different recipient.  We consider the problem of publically
verifying that the outputs are indeed a permutation of the inputs. Moreover, we
require that the correspondence not be revealed. Andrew Neff describes in
\cite{neff01} a method for proving a shuffle in zero-knowledge.

Neff's solution is based on the ElGamal public key encryption scheme, which is
known to be semantically secure assuming the discrete log problem (decisional
Diffie-Hellman, or DDH) is hard \cite{elgamal84}. Based on this assumption, Neff
proves his protocol achieves a property known as honest verifier zero-knowledge
(HVZK) \cite{goldreich}. Informally speaking, this means that as long as the verifier
faithfully executes the protocol, the mix can prove the outputs are a
permutation of the inputs without revealing the permutation.

I formulate and define security for the problem and present Neff's protocol.
For simplicity, I limit the discussion to a mixnet with a single mix server. In
this scenario, users encrypt their messages under the public key of the mix. The
mix waits until it receives a full batch of ciphertexts, decrypts them under its
private key, and shuffles the output. In section~\ref{section:prelim}, I specify
ElGamal encryption, describe the DDH assumption, and sketch the HVZK notion. In
section~\ref{section:neff-shuffle}, I present the protocol and sketch its
security. I implement the general $k$-shuffle as described in this section in
the Go programming language.\footnote{ Freely available at {\it
github.com/cjpatton/shuffle}.}

\section{Preliminaries} \label{section:prelim}

If $X$ is a finite set, let $x \getsr X$ denote uniformly sampling an
element $x$ from the set. Let $y \gets A(x)$ denote running $A$ on input $x$ and
assigning its output to $y$. Let $y \gets A(x; r)$ denote the execution of a
probabilistic algorithm with the sequence of coins $r \in \bits^\infty$. Let $y
\getsr A(x)$ denote choosing $r \getsr \bits^\infty$ and executing $y \gets
A(x; r)$. Let $[i..j]$ where $i \le j$ denote the set of integers from $i$ to
$j$ inclusive.
Let $y \getsr \brackets{P, V}(x)$ denote the probabilistic execution of
interactive Turing machines $P$ and $V$ on common input $x$. When the protocol
finishes, the output of $V$ is assigned to $y$.
$x$ is called the common input of $P$ and $V$.
Finally a function $\Delta(n)$ is
negligible if for all positive polynomials
$p(\cdot)$ and sufficiently large $n$, $\Delta(n) < \frac{1}{p(n)}$.


\subsection{ElGamal encryption}

Fix a prime number $p$ and let $\Zmodp$ denote the modular ring of order $p$.
In what follows, we assume arithmetic is performed in the modular ring $\Zmodp$.
Let $g \in \Zmodp$ such that $g^q = 1$ where $q$ is prime. Then $\brackets{g} =
\Zmodq^*$ is a subgroup of $\Zmodp^*$ and $q | (p-1)$. We call $(p, q, g)$ the
\textit{public parameters}. The \textit{secret-key} is chosen uniformly from
the set of powers of $g$ mod $p$: let $\sk \getsr [1..q-1]$. Let $\pk = g^\sk$ be
the \textit{public-key}. Key generation is denoted $(K, k) \getsr \gen(p, q,
g)$.
Encryption and decryption operate on group elements.\footnote{
Public-key encryption schemes are typically defined on bit
strings. It is easy to messages as elements of $\Zmodp^*$, but the number of
messages that can be encoded depends on the modulus $p$.}
Encryption of $M \in \Zmodp^*$ proceeds as follows:
Let $r \getsr [1..q-1]$,
$R = g^r$,
$S = K^r$, and
$C = M \cdot S$.
Output the tuple $(C, R)$.
This is denoted $(C, R) \getsr \enc_K(M)$.
Decryption of a ciphertext $(C, R) \in \Zmodp^* \by \Zmodp^*$ proceeds as follows:
let $S = R^\sk$ and
$M = C \cdot S^{-1}$.
Output $M$.
This is denoted $M \gets \dec_k(C, R)$.

ElGamal is known to be \textit{semantically secure} under the
decisional Diffie-Hellman assumption \cite{elgamal84,ty98}. Informally speaking, this
means that if given $\pk$, it is infeasible for any adversary to determine
$\sk$, then given $(C,R)$, it is infeasible for any adversary to
learn anything meaningful about $M$ (nor $m$). As we're not
interested in the security of ElGamal from a privacy standpoint, we won't
formalize semantic security. However, we define the DDH assumption in the next
subsection.

The mixnet operates as follows:
let $\varm_1, \ldots, \varm_n \in \Zmodp^*$ be a sequence of plaintexts.
Let $(\varc_1, \varr_1), \ldots, (\varc_n, \varr_n) \in \Zmodp^* \by \Zmodp^*$ be a
sequence of corresponding ElGamal ciphertexts encrypted under the public-key
$\pk$. The mix server, who possesses the secret-key $\sk$, takes as input
the ciphertexts and outputs a sequence $\varm_{\pi(1)}, \ldots, \varm_{\pi(n)}$
where $\pi$ is a permutation on $[1..n]$.
We remark that there is a natural extension of this scheme for mixnets with a
cascade of servers, each possessing its own decryption key \cite{cm06}. Indeed,
Camenisch and Mityagin use the Neff proof in order to verify the output of each
mix in the cascade. If a dishonest mix is detected, the protocol is run without
without using it.

\subsection{Decisional Diffie-Hellman}

Let $(p, q, g)$ be the public parameters of the ElGamal cryptosystem. The game
the adversary $\advD$ plays is defined as follows: let $a, b, r \getsr
[1..q-1]$ and let $A = g^a$, $B = g^b$, $Y_0 = g^r$, and $Y_1 = g^{ab}$. Choose
a random bit $b \getsr \bits$. On input $(A, B, Y_b)$, the adversary outputs a
bit $b^\prime \in \bits$ and wins if $b=b^\prime$. The advantage of $\advD$ is
defined as
\[
  \Delta(q) = |\Pr[\advD(A, B, Y_1)=1] - \Pr[\advD(A, B, Y_0)=1]|
\]
The DDH assumption is that, for every polynomial-time adversary $\advD$, the
function $\Delta(q)$ is negligible.

\subsection{Honest verifier zero-knowledge}

Zero-knowledge is defined in \cite{goldreich} with respect to the class of
formal languages with interactive proof systems. A language $L$ has an
interactive proof system if there exists a pair of probabilistic algorithms $(P,
V)$ such that for all $x \in L$, $\Pr[\brackets{P, V}(x) = 1] = 1$, and for all
$x \not\in L$, $\Pr[\brackets{P, V}(x) = 1] \le 1/2$. The class of languages
with interactive proof systems is denoted $\class{IP}$.
%TODO(cjpatton) verify in Goldreich

Let $L \in \class{IP}$
exhibited by $(P, V)$. We define security with respect to a game associated to
adversary $D$, verifier $V^*$, and simulator $M^*$. Suppose that $L$ is a finite
set\footnote{This is without loss of generality, since we
consider polynomial-time adversaries.} and let $x \getsr L$. Let $y_1 \getsr
\brackets{P, V^*}(x)$ and $y_0 \getsr M^*(x)$ choose a bit $b \getsr \bits$.
On input $(x, y_b)$, adversary $\advD$ outputs a bit $b^\prime$ and wins if
$b=b^\prime$. Let $k = |L|$ and define the advantage of $\advD$ as
\[
  \Delta(k) = |\Pr[\advD(x, y_1)=1] - \Pr[\advD(x, y_0)=1]|
\]
We say that $(P, V)$ is \emph{computational zero-knowledge} (or just
\emph{zero-knowledge}) if
for every probabilistic polynomial-time adversary $\advD$ and
  for every probabilistic polynomial-time verifier $V^*$,
    there exists probabilistic polynomial-time simulator $M^*$ such that $\Delta(k)$ is
    negligible.
The security notion achieved by Neff's protocol is somewhat weaker: a proof system $(P, V)$ is
\emph{honest verifier zero-knowledge} (HVZK) if
for every probabilistic polynomial-time adversary $\advD$,
  there exists a probabilistic polynomial-time simulator $M^*$ such that
\[
  |\Pr[\advD(x, \brackets{P,V}(x))=1] - \Pr[\advD(x, M^*(x))=1]|
\]
is a negligible function of $k$.
%TODO(cjpatton) verify in Goldreich

\section{The Neff shuffle} \label{section:neff-shuffle}

We now give the syntax of an interactive proof system for mixnets. The prover
$P$ (nominally the mix server) possesses the secret-key $\sk$ and the verifier $V$ possesses
the public-key $\pk$. The common input of $P$ and $V$ is all of the messages passed through the
mix server. The mix takes as input a sequence of ciphertexts $(\varc_1,
\varr_1), \ldots, (\varc_n, \varr_n) \in \Zmodp^* \by \Zmodp^*$ and outputs a
sequence of plaintexts $\varm_{1}, \ldots, \varm_{n} \in \Zmodp^*$. Let $x \in
\bits^*$ denote the encoding of these messages. We say $x \in L$ if and only if
there exists a bijection $\pi : [1..n] \rightarrow [1..n] $ such that for every $i \in [1..n]$,
$\varm_{\pi(i)} = \dec_k(\varc_{i}, \varr_{i})$.

A trivial proof system for $L$ is one in which the prover transmits to the
verifier its secret-key and the verifier decrypts each of the ciphertexts. Of
course, this completely exposes $\pi$. Our goal is to specify a proof system $(P,
V)$ in which $P$ convinces $V$ of the existence of $\pi$ without revealing the
permutation or the secret key. A proof system that is HVZK is sufficient to
achieve this goal, assuming the DDH problem is hard. Such a proof system is
given by the general $k$-shuffle protocol defined in
section~\ref{section:gen-k-shuffle}. It is built upon two simpler protocols,
which we define in sections~\ref{section:ilmpp}
and~\ref{section:simple-k-shuffle}.

\subsection{The basic protocol and its security} \label{section:ilmpp}
Not useful yet ...

\subsection{Simple $k$-shuffle} \label{section:simple-k-shuffle}
Not useful yet ...

\subsection{General $k$-shuffle} \label{section:gen-k-shuffle}
This is what we actually implement.


\begin{thebibliography}{99}

  \bibitem{chaum81} David Chaum, 1981. ``Untraceable electronic mail, return addresses, and digital pseudonyms.''
    {\tt http://freehaven.net/anonbib/cache/chaum-mix.pdf}

  \bibitem{elgamal84} Taher Elgamal, ``A public key cryptosystem and a signature
    scheme based on discrete logarithms.'' Appeared in \textit{CRYPTO'84.}

  \bibitem{cp92}  D. Chaum and T.P. Pedersen. ``Wallet databases with
    observers.'' Appeared in \textit{CRYPTO'92.}

  \bibitem{ty98} Yiannis Tsiounis and Moti Yung 1998. ``On the security of
    ElGamal based encryption.'' Appeared in \textit{PKC'98.}

  \bibitem{goldreich} Oded Goldreich, 2001. \textit{Foundations of Cryptography.}

  \bibitem{neff01} C. Andrew Neff, 2001. ``A verifiable secret shuffle and its application to e-voting.'' {\tt http://freehaven.net/anonbib/cache/shuffle:ccs01.pdf}

  \bibitem{cm06} Jan Camenisch and Anton Mityagin, 2006. ``Mix-network with
    stronger security.''

\end{thebibliography}

\end{document}
